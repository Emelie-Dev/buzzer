Pages =>
 - Home
 - Search
 - Following
 - Reels
 - Inbox
 - Profile
 - Notifications
 - More (settings, saved, history, logout, app theme)


    Home page =>
        Content Box (Menu list)
            - Follow
            - Report
            - Not interested
            - Add to story(optional)
            - Clear display
            - Go to post

 Updates =>
  - Change appearance icon based on theme
  - Add storyborder to fyp profile pictures ✔
  - Pause video when comment section is displayed ✔
  - Fix comment box for reels(clicking of black background) ✔
  - Fix active video when exiting modals from transparent background ✔
  - Remeber to revoke object urls after file upload.
  - Pause active video for all modals.
  - Create analytics page
  - Show email in proile page
  - Hide search before any page unmounts


Server =>
  - Collections
    - Users
      - Actions 
        - Normal (follow, unfollow, add friend, remove friend)
        - Auth (manage devices)

    - Story
      - Actions (create, get stories, get user story, delete story, hide story, like story (use notification to detect), comment on story)

    - Contents
        - Actions (create, delete, like, comment, save, get contents, get content, not interested)

    - Notifications

  - Worker threads
    - Image resizing after upload for different display sizes (profile picture, thumbnails).
    - Video transcoding to different formats and resolutions for streaming.
    - Image filtering or applying effects to user-uploaded images.
    - Video processing (e.g., trimming, adding watermarks) before display.
    - Thumbnail generation from video files to display previews.
    - Compression of media files (images/videos) to reduce storage size.
    - Metadata extraction (e.g., EXIF data from images or video duration) after upload.
    - Automatic content moderation (e.g., detecting inappropriate content in images/videos).
    - Generating animated GIFs from video clips.
    - Audio processing (e.g., normalization or conversion) for videos with sound.

  Tips
  - Enable chat feature
  - Users can have only 1000 friends at max
  - Enable users to view sent friend requests
  - Handle duplicate documents in pagination
  - Delete failed processed files from cloudinary
 









export const handleSearch = asyncErrorHandler(
  async (req: AuthRequest, res: Response) => {
    let {
      query,
      page,
      firstUserCreatedAt,
      lastUserCreatedAt,
      firstContentCreatedAt,
      lastContentCreatedAt,
    } = req.query;
    query = String(query).toLowerCase().trim();

    // Check is search exists
    const userSearch = await Search.findOne({
      query,
      searchedAt: {
        $gte: new Date(Date.now() - 1000 * 60 * 60 * 24 * 7),
      },
    });

    if (userSearch) {
      await Search.findByIdAndUpdate(userSearch._id, {
        $inc: { searchCount: 1 },
      });
    } else {
      const location = await getUserLocation(req.clientIp);

      await Search.create({
        user: req.user?._id,
        query,
        location,
      });
    }

    // Update user search history
    const searchHistory = new Set(req.user?.searchHistory || []);
    searchHistory.add(query);

    if (searchHistory.size > 10) {
      const firstElem = Array.from(searchHistory)[0];
      searchHistory.delete(firstElem);
    }

    const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
        searchHistory: [...searchHistory],
      },
      {
        runValidators: true,
        new: true,
      }
    );
    const userData = protectData(user as Document, 'user');

    // Get reels, contents, users

    // Get users
    const matchedUsers = await queryFromTypesense(
      'users',
      {
        q: query,
        query_by: 'username,name',
        filter_by:
          Number(page) === 1
            ? `id:!=${String(req.user?._id)}`
            : `id:!=${String(req.user?._id)} && createdAt:>${Number(
                firstUserCreatedAt
              )} && createdAt:<${Number(lastUserCreatedAt)}`,
        page: Number(page),
        per_page: 30,
        sort_by: 'createdAt:desc',
      },
      ['username', 'photo', 'name', 'createdAt']
    );

    // Get users followers and contents
    const followersData = await Follow.aggregate([
      {
        $match: {
          following: {
            $in: matchedUsers?.map((user) =>
              mongoose.Types.ObjectId.createFromHexString(user.id)
            ),
          },
        },
      },
      {
        $group: {
          _id: '$following',
          followers: { $sum: 1 },
        },
      },
    ]);
    const users = await Promise.all(
      matchedUsers?.map(async (user, index) => {
        const followerObj = followersData.find(
          (doc) => String(doc._id) === user.id
        );
        user.followers = followerObj ? followerObj.followers : 0;

        if (Number(page) === 1) {
          if (index === 0 || index === 1 || index === 2) {
            // - Check if user is friend
            user.latestContents = await Content.find({
              user: user.id,
              'settings.accessibility': ContentAccessibility.EVERYONE,
            })
              .sort({ createdAt: -1 })
              .limit(2);
          }
        }

        return user;
      })!
    );

    // Get contents
    const matchedContents = await queryFromTypesense(
      'contents',
      {
        q: query,
        query_by: 'description',
        filter_by:
          Number(page) === 1
            ? `user:!=${String(req.user?._id)}`
            : `user:!=${String(req.user?._id)} && createdAt:>${Number(
                firstContentCreatedAt
              )} && createdAt:<${Number(lastContentCreatedAt)}`,
        page: Number(page),
        per_page: 30,
        sort_by: 'createdAt:desc',
      },
      ['user', 'description', 'createdAt', 'media']
    );

    // Get contents owners details
    const contentsOwners = await User.find({
      _id: { $in: matchedContents?.map(({ user }) => user) },
    }).select('username photo');

    // Get contents views
    const viewCounts = await View.aggregate([
      {
        $match: {
          collectionName: 'content',
          documentId: {
            $in: matchedContents?.map((user) =>
              mongoose.Types.ObjectId.createFromHexString(user.id)
            ),
          },
        },
      },
      {
        $group: {
          _id: { documentId: '$documentId' },
          views: { $sum: 1 },
        },
      },
    ]);

    const contents = matchedContents?.map((content) => {
      const user = contentsOwners.find(
        (user) => String(user._id) === content.user
      );
      const views = viewCounts.find(
        (data) => String(data._id.documentId) === content.id
      ).views;
      const media = JSON.parse(content.media)[0];

      return { ...content, user, media, views };
    });

    return res.status(200).json({
      status: 'success',
      data: {
        result: {
          // users,
          // contents,
        },
        user: userData,
      },
    });
  }
);